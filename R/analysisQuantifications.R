# ------------------------------------------------------------------------------
#' @title Analysis of the Relative Quantifications
#'
#' @description Analysis of relative quantifications, including:
#'
#' - Annotations
#' - Summary files in different format (xls, txt) and shapes (long, wide)
#' - Numerous summary plots
#' - Enrichment analysis using Gprofiler
#' - PCA of quantifications
#' - Clustering analysis
#' - Basic imputation of missing values
#'
#' @param log2fc_file (char) MSstats results file location
#' @param modelqc_file (char) MSstats modelqc file location
#' @param species (char) Select one species. Species currently supported for
#' a full analysis (including enrichment analysis):
#' - HUMAN
#' - MOUSE
#' 
#' To find out species supported only for annotation check 
#' `?artmsIsSpeciesSupported()`
#' 
#' @param output_dir (char) Name for the folder to output the results from the 
#' function. Default is current directory (recommended to provide a new folder
#' name).
#' @param outliers (char) It allows to keep or remove outliers. Options:
#' - `keep` (default): it keeps outliers 'keep', 'iqr', 'std'
#' - `iqr` (recommended): remove outliers +/- 6 x Interquartile Range (IQR)
#' - `std` : 6 x standard deviation
#' @param enrich (logical) Performed enrichment analysis using GprofileR?
#' Only available for species HUMAN and MOUSE. 
#' `TRUE` (default if "human" or "mouse" are the species) or `FALSE`
#' @param l2fc_thres (int) log2fc cutoff for enrichment analysis (default,
#' `l2fc_thres = 1.5`)
#' @param choosePvalue (char) specify whether `pvalue` or `adjpvalue` should 
#' use for the analysis. The default option is `adjpvalue`
#' (multiple testing correction).
#' But if the number of biological replicates for a given experiment is
#' too low (for example n = 2), then `choosePvalue = pvalue` is recommended.
#' @param isBackground (char) background of gene names for enrichment analysis.
#' `nobackground` (default) will use the total number of genes detected.
#' Alternatively provided the file path name to the background gene list.
#' @param isPtm (char) Is a ptm-site quantification? 
#' - `global` (default), 
#' - `ptmsites` (for site specific analysis), 
#' - `ptmph` (Jeff Johnson script output evidence file)
#' @param mnbr (int) minimal number of biological replicates for imputation
#' and filtering. Default: `mnbr = 2` (Proteins must be found in one of the
#' conditions in at least 2 of the biological replicates)
#' @param isFluomics (logical) Does this data belong to the FluOMICs project?
#' `TRUE` or `FALSE` (default)
#' @param pathogen (char) Is there a pathogen in the dataset as well?
#' if it does not, then use `pathogen = nopathogen` (default).
#' Pathogens available: `tb` (Tuberculosis), `lpn` (Legionella)
#' @param plotPvaluesLog2fcDist (logical) If `TRUE` (default) plots pvalues
#' and log2fc distributions
#' @param plotAbundanceStats (logical) If `TRUE` (default) plots stats graphs
#' about abundance values
#' @param plotReproAbundance (logical) If `TRUE` plots reproducibility
#' based on normalized abundance values
#' @param plotCorrConditions (logical) If `TRUE` plots correlation  
#' between the different conditions
#' @param plotCorrQuant (logical) if `TRUE` plots correlation between the
#' available quantifications (comparisons)
#' @param plotPCAabundance (logical) if `TRUE` performs PCA analysis of
#' conditions using normalized abundance values
#' @param plotFinalDistributions (logical) if `TRUE` plots distribution of both
#' log2fc and pvalues
#' @param plotPropImputation (logical) if `TRUE` plots proportion of overall
#' imputation
#' @param plotHeatmapsChanges (logical) if `TRUE` plots heatmaps of quantified
#' changes (both all and significant only)
#' @param plotTotalQuant (logical) if `TRUE` plots barplot of total number of
#' quantifications per comparison
#' @param plotClusteringAnalysis (logical) if `TRUE` performs clustering
#' analysis between quantified comparisons (more than 1 comparison required)
#' @param verbose (logical) `TRUE` (default) shows function messages
#' @return (data.frame) summary of quantifications, including annotations, 
#' enrichments, etc
#' @keywords analysis, quantifications
#' @examples
#' # Testing that the files cannot be empty
#' artmsAnalysisQuantifications(log2fc_file = NULL,
#'                               modelqc_file = NULL,
#'                               species = NULL,
#'                               output_dir = NULL)
#' @export
artmsAnalysisQuantifications <- function(log2fc_file,
                                         modelqc_file,
                                         species,
                                         output_dir = "analysis_quant",
                                         outliers = c("keep", "iqr", "std"),
                                         enrich = TRUE,
                                         l2fc_thres = 1,
                                         choosePvalue = c("adjpvalue","pvalue"),
                                         isBackground = "nobackground",
                                         isPtm = "global",
                                         mnbr = 2,
                                         isFluomics = FALSE,
                                         pathogen = "nopathogen",
                                         plotPvaluesLog2fcDist = TRUE,
                                         plotAbundanceStats = TRUE,
                                         plotReproAbundance = TRUE,
                                         plotCorrConditions = TRUE,
                                         plotCorrQuant = TRUE,
                                         plotPCAabundance = TRUE,
                                         plotFinalDistributions = TRUE,
                                         plotPropImputation = TRUE,
                                         plotHeatmapsChanges = TRUE,
                                         plotTotalQuant = TRUE,
                                         plotClusteringAnalysis = TRUE,
                                         verbose = TRUE
                                         ) {
  if(verbose){
    message("---------------------------------------------")
    message("artMS: ANALYSIS OF QUANTIFICATIONS")
    message("---------------------------------------------")
  }
  
  if(any(missing(log2fc_file) | 
         missing(modelqc_file) |
         missing(species) ))
   stop("One (or many) of the required arguments missed. 
        Please, check the help for this function to find out more")
  
  if(is.null(log2fc_file) & is.null(modelqc_file) & 
     is.null(species) & is.null(output_dir)){
    return("The evidence_file, modelqc_file, species and output_dir arguments cannot be NULL")
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Checking arguments

  # CHECK POINT: DO THE FILES EXIST?
  if(!file.exists(log2fc_file)){
    stop("THE FILE ", log2fc_file, " DOES NOT EXIST ")
  }
  
  if(!file.exists(modelqc_file)){
    stop("THE FILE ", modelqc_file, " DOES NOT EXIST ")
  }
  
  if (!is.logical(enrich)) {
    stop(" Argument <enrich> must be logical (TRUE or FALSE) ")
  }

  if (!is.logical(isFluomics)) {
    stop(" Argument <isFluomics> must be logical (TRUE or FALSE) ")
  }

  if (!is.numeric(l2fc_thres)) {
    stop(" Argument <l2fc_thres> must be numeric ")
  }
  
  if (!is.numeric(mnbr)) {
    stop(" Argument <mnbr> must be numeric ")
  }

  if(!(isPtm %in% c('global', 'ptmph', 'ptmsites'))){
    stop("The < isPtm > argument is wrong. 
         The valid options are: <global> or <ptmsites> ")
  }
  
  outliers <- tolower(outliers)
  outliers <- match.arg(outliers)
  
  choosePvalue <- tolower(choosePvalue)
  choosePvalue <- match.arg(choosePvalue)
  
  # CHECK IF THE SPECIES IS SUPPORTED
  if(isFALSE(artmsIsSpeciesSupported(species))){
    if(verbose) message("----(-) ", species, " is not supported. \n\tGene Symbol, Protein Name, and EntrezID won't be provided")
  }
  
  # Because the species is known to be supported, let's keep going...
  species <- tolower(species)
  if(!(species %in% c('human', 'mouse'))){
    if(enrich){
      message("--- Enrichment analysis turned off (only available for HUMAN and MOUSE)")
      enrich <- FALSE
    }
  }
  
  pathogen <- tolower(pathogen)
  if (pathogen == "nopathogen") {
    if(verbose) message("--- No Pathogen extra in these samples")
  } else if (pathogen == "tb") {
    # This should not work
    if(verbose) message("\tPATHOGEN IN SAMPLES: Tuberculosis (TB) ")
    pathogen.ids <- artms_data_pathogen_TB
    names(pathogen.ids) <- c('Entry')
  } else if (pathogen == "lpn") {
    if(verbose) message("\tPATHOGEN IN SAMPLES: LEGIONELLA PNEUMOPHILA ")
    pathogen.ids <- artms_data_pathogen_LPN
  } else{
    stop("This pathogen is not supported yet")
  }
  
  session <- sessionInfo()
  sink("sessionInfoArtMS.txt")
  print(session)
  sink()
  
  output_dir <- paste0(output_dir, "_", choosePvalue)
  
  # create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }
  
  # LOADING ABUNDANCE
  if(verbose) message(">> LOADING modelqc FILE (ABUNDANCE) ")
  dfmq <- read.delim(modelqc_file,
                     header = TRUE,
                     sep = "\t",
                     stringsAsFactors = FALSE
                     )
  
  # Removing the empty protein names
  if (any(dfmq$PROTEIN == "")) {
    dfmq <- dfmq[-which(dfmq$PROTEIN == ""), ]
    if(verbose) message("--- Empty ID proteins removed from abundance data")
  }
  dfmq$PROTEIN <- gsub("(sp\\|)(.*)(\\|.*)", "\\2", dfmq$PROTEIN)
  dfmq$PROTEIN <- gsub("(.*)(\\|.*)", "\\1", dfmq$PROTEIN)
  
  # CHECK THE PROTEIN ID
  if( length(dfmq$PROTEIN[grep("\\w{2}_\\d{1,}\\.\\d{1,}", dfmq$PROTEIN)]) > 100 ){
    if(verbose) message("----(-) Many RefSeq IDs detected in this dataset, which is not supported yet.
                        Gene Symbol, Protein Name, and EntrezID won't be provided")
  }
  
  # # Remove outliers
  if (outliers == "iqr" | outliers == "std"){

    if(outliers == "iqr"){
      if(verbose) message("--- Removing outliers (based on 6xIQR cutoff)")
      iqr <- IQR(dfmq$ABUNDANCE)
      m <- mean(dfmq$ABUNDANCE)
      uplim <- m+(6*iqr)
      lowlim <- m-(6*iqr)
    }else if(outliers == "std"){
      if(verbose) message("--- Removing outliers (based on 6xSTD cutoff)")
      std <- sd(dfmq$ABUNDANCE)
      m <- mean(dfmq$ABUNDANCE)
      uplim <- m+3*std
      lowlim <- m-3*std
    }

    # Record outliers for plotting
    dfmq$outliers <- ifelse(dfmq$ABUNDANCE > lowlim & dfmq$ABUNDANCE < uplim, "no", "yes")
    
    outliers_number <- length(dfmq$outliers[which(dfmq$outliers == "yes")])
    
    # Report outliers removed
    if (outliers_number == 0){
      if(verbose) message("------> No outliers have been removed")
    }else{
      if(verbose) message("------> Total outliers removed: ", outliers_number)
      out.outliers <- gsub(".txt", paste0("-outliers-removed-",outliers,".txt"), log2fc_file)
      out.outliers <- paste0(output_dir, "/", out.outliers)
      dfmq.outliers <- dfmq[which(dfmq$outliers == "yes"),]
      write.table(
        dfmq.outliers,
        out.outliers,
        quote = FALSE,
        sep = "\t",
        row.names = FALSE,
        col.names = TRUE
      )
      
      # PLOT Outliers
      k <- ggplot(dfmq, aes(x = SUBJECT_ORIGINAL, y = ABUNDANCE, color = outliers))
      k <- k + geom_jitter(width = 0.3, size = 0.5)
      k <- k + theme_minimal()
      k <- k + ggtitle("Distribution of ABUNDANCE with outliers")
      k <-k + theme(axis.text.x = element_text(
        angle = 90,
        hjust = 1,
        vjust = 0.5
      ))
      
      # Distribution without ouliers
      l <- ggplot(dfmq[which(dfmq$outliers == "no"),], aes(x = SUBJECT_ORIGINAL, y = ABUNDANCE))
      l <- l + geom_jitter(width = 0.3, size = 0.5)
      l <- l + theme_minimal()
      l <- l + ggtitle("Distribution of ABUNDANCE (outliers removed)")
      l <- l + theme(axis.text.x = element_text(
        angle = 90,
        hjust = 1,
        vjust = 0.5
      ))
      
      out.outliers <- gsub(".txt", paste0("-outliers-removed-",outliers,".pdf"), log2fc_file)
      out.outliers <- paste0(output_dir, "/", out.outliers)
      pdf(out.outliers)
      plot(k)
      plot(l)
      garbage <- dev.off()
      
      if(verbose) message("------> Check table and plot to find out more about outliers removed")

      # Remove outliers
      dfmq <- dfmq[which(dfmq$ABUNDANCE > lowlim & dfmq$ABUNDANCE < uplim), ]
    }
  }else{
    if(verbose) message("--- Outliers kept (user selection)")
    dfmq <- dfmq
  }

  # First, let's take the conditions, which will be used later in several places
  conditions <- unique(dfmq$GROUP_ORIGINAL)
  numberConditions <- length(conditions)
  
  # KEY STEP: GETTING THE BACKGROUND GENE LIST
  if (isBackground == "nobackground") {
    # If not list of background genes is provided,
    # then extract them from the modelqc file
    if (isPtm == "global") {
      suppressMessages(dfmq2Genes <- artmsAnnotationUniprot(dfmq, 'PROTEIN', species))
      numberTotalGenes <- length(unique(dfmq2Genes$Gene))
      if(verbose) message("--- Total number of genes/proteins: ",
          numberTotalGenes,
          " ")
      listOfGenes <- unique(dfmq2Genes$Gene)
    } else if (grepl("ptm", isPtm)) {
      dfmq2Genes <- dfmq[c('PROTEIN', 'GROUP_ORIGINAL')] 
      names(dfmq2Genes)[grep('PROTEIN', names(dfmq2Genes))] <- 'Protein'
      # # Removing party sites
      # dfmq2Genes <- dfmq2Genes[grep(",", dfmq2Genes$Protein, invert = TRUE), ]
      
      dfmq2Genes <- .artmsExtractUniprotId(x = dfmq2Genes, 
                                           uniprotPtmColumn = "Protein", 
                                           newColumnName = "Protein")
      
      dfmq2Genes <- unique(dfmq2Genes)
      suppressMessages(dfmq2Genes <- artmsAnnotationUniprot(dfmq2Genes, 'Protein', species))
      numberTotalGenes <- length(unique(dfmq2Genes$Gene))
      if(verbose) message("--- TOTAL NUMBER OF GENES/PROTEINS: ",
          numberTotalGenes, "  ")
      if (numberTotalGenes == 0) {
        stop("IDs are not recognized")
      }
      listOfGenes <- unique(dfmq2Genes$Gene)
    }
  } else{
    # No matter what list is provided, it must come with a "Gene" column
    backgroundList <- read.delim(isBackground,
                                 header = TRUE,
                                 sep = "\t",
                                 quote = "",
                                 stringsAsFactors = FALSE)
    listOfGenes <- unique(backgroundList$Gene)
  }
  
  backgroundNumber <- length(listOfGenes)
  
  #-----------------------------------------------------------------------------
  # LOG2FC
  if(verbose) message(">> LOADING QUANTIFICATIONS (-results.txt from MSstats) ")
  dflog2fcraw <- read.delim(log2fc_file,
                            header = TRUE,
                            sep = "\t",
                            stringsAsFactors = FALSE
                            )
  if (any(dflog2fcraw$Protein == "")) {
    dflog2fcraw <- dflog2fcraw[-which(dflog2fcraw$Protein == ""), ]
    if(verbose) message("--- Empty ID proteins removed from log2fc data")
  }
  dflog2fcraw$Protein <- gsub("(sp\\|)(.*)(\\|.*)", "\\2", dflog2fcraw$Protein)
  dflog2fcraw$Protein <- gsub("(.*)(\\|.*)", "\\1", dflog2fcraw$Protein)
  
  dflog2fcfinites <- dflog2fcraw[is.finite(dflog2fcraw$log2FC), ]
  
  
  
  # Removing log2fc outliers?
  cutofflog2fc <- 15
  if(verbose) message(
    "--- Removing log2fc outliers (",
    paste0("-", cutofflog2fc, " < log2fc < +", cutofflog2fc),
    ") "
  )
  
  filtermorethan10 <- length(dflog2fcfinites$log2FC[abs(dflog2fcfinites$log2FC) > cutofflog2fc])
  if (filtermorethan10 > 0) {
    if(verbose) message("------ (-) Removing [",
                        filtermorethan10,
                        "] protein ids with a abs(log2fc) >",
                        cutofflog2fc, 
                        " ")
    dflog2fcfinites <- dflog2fcfinites[-which(abs(dflog2fcfinites$log2FC) > cutofflog2fc), ]
  }
  
  # IMPUTING MISSING VALUES
  # When a value is completely missed in one of the conditions,
  # the log2fc = Inf / -Inf. Here, we impute those values.
  # The imputation method works as follow. The assumption is that those
  # proteins are likely present as well in those conditions where are missed, 
  # but due to the
  # small sampling (usually 2 or 3 biological replicas) and other proteomics
  # related issue, those proteins didn't make it through the level of detection.
  # Therefore, a small intensity (sampled from the bottom 5%) will be assigned
  # to the protein/site in the missing condition, and the new log2fc is 
  # re-calculated out of the MSstats box. Two issues are addressed in this way
  # 1. If a protein has been consistently identified in one of the conditions, 
  # it will stay
  # 2. But if the intensity value in those conditions was too low, then the 
  # log2fc will be also low
  
  if(verbose) message(">> IMPUTING MISSING VALUES ")
  # Select infinite values (i.e., log2fc missed for that)
  dflog2fcinfinites <- dflog2fcraw[is.infinite(dflog2fcraw$log2FC), ]
  numberInfinites <- dim(dflog2fcinfinites)[1]
  
  # Control
  if (numberInfinites < 1) {
    if(verbose) message(" WARNING: O Infinite values (not very usual)")
  } else {
    if(verbose) message("--- Number of +/- INF values: ", dim(dflog2fcinfinites)[1], " ")
    
    imputedL2FCmelted <- .artms_imputeMissingValues(dflog2fcinfinites, dfmq)
    
    # Merge with the original log2fc values to impute...
    theImputedL2FC <- merge(dflog2fcinfinites,
                            imputedL2FCmelted,
                            by = c("Protein", "Label"),
                            all = FALSE)
    # check size of theImputedL2FC compared with dflog2fcinfinites to see if we lost rows during imputation
    # possibly we were unable to impute rows after removing outliers
    if (nrow(theImputedL2FC) != nrow (dflog2fcinfinites)){
      numMissing = nrow (dflog2fcinfinites) - nrow(theImputedL2FC)
      message(" WARNING:  Failed to impute values for ", numMissing, "rows. Possibly due to outlier removal")
    }
      
    theImputedL2FC$imputed <- "yes"
  }
  
  # Getting the data ready for merging
  dflog2fcfinites$imputed <- "no"
  dflog2fcfinites$iLog2FC <- dflog2fcfinites$log2FC
  
  # Choose the pvalue or adjusted pvalue as the iPvalue
  if (choosePvalue == "pvalue") {
    dflog2fcfinites$iPvalue <- dflog2fcfinites$pvalue
  } else if (choosePvalue == "adjpvalue") {
    dflog2fcfinites$iPvalue <- dflog2fcfinites$adj.pvalue
  } else{
    stop("Only <pvalue> or <adjpvalue> for argument <choosePvalue>")
  }
  
  # Merging: NA values are thrown away at this point
  if (numberInfinites < 1) {
    dflog2fc <- dflog2fcfinites
  } else {
    dflog2fc <- rbind(dflog2fcfinites, theImputedL2FC)
  }
  
  if(plotPvaluesLog2fcDist){
    if(verbose) message("--- Plotting distributions of log2fc and pvalues ")
    
    plotDFdistColor <-
      ggplot(dflog2fc, aes(x = log2FC, fill = Label)) +
      geom_histogram(bins = 100,
                     alpha = .4,
                     col = "black", 
                     na.rm = TRUE) +
      labs(title = "Distribution log2FC", x = "log2FC")
    
    plotDFdistAll <- ggplot(dflog2fc, aes(x = log2FC)) +
      geom_histogram(bins = 100,
                     alpha = .4,
                     col = "black", 
                     na.rm = TRUE) +
      labs(title = "Distribution log2FC", x = "log2FC")
    
    plotDFdistiLog <- ggplot(dflog2fc, aes(x = iLog2FC)) +
      geom_histogram(bins = 100,
                     alpha = .4,
                     col = "black", 
                     na.rm = TRUE) +
      labs(title = "Distribution ilog2FC (imputed + nonimputed", x = "iLog2FC")
    
    plotPvalues <-
      ggplot(dflog2fc[is.finite(dflog2fc$pvalue), ], aes(x = pvalue)) +
      geom_histogram(bins = 50,
                     alpha = .4,
                     col = "black",
                     na.rm = TRUE) +
      labs(title = "Distribution p-values", x = "p-values")
    
    plotAdjustedPvalues <-
      ggplot(dflog2fc[-which(dflog2fc$adj.pvalue == 0), ], aes(x = adj.pvalue)) +
      geom_histogram(bins = 150,
                     alpha = .4,
                     col = "black",
                     na.rm = TRUE) +
      labs(title = "Distribution adj.pvalues", x = "adj.values")
    
    plotAdjustedIpvalues <- ggplot(dflog2fc, aes(x = iPvalue)) +
      geom_histogram(bins = 150,
                     alpha = .4,
                     col = "black",
                     na.rm = TRUE) +
      labs(title = "Distribution imputed p-values", x = "iPvalues")
    
    
    # DISTRIBUTION PRINT OUTS
    distributionsOut <- gsub(".txt", ".distributions.pdf", log2fc_file)
    distributionsOut <- paste0(output_dir, "/", distributionsOut)
    pdf(distributionsOut)
    plotDFdistColor
    plotDFdistAll
    plotDFdistiLog
    plotPvalues
    plotAdjustedPvalues
    plotAdjustedIpvalues
    
    if (numberInfinites > 0) {
      hist(
        imputedL2FCmelted$iLog2FC,
        breaks = 100,
        main = paste0("Imputed Log2FC (all)\n n = ", dim(imputedL2FCmelted)[1]),
        xlab = "log2fc"
      )
      hist(
        theImputedL2FC$iLog2FC,
        breaks = 100,
        main = paste0("Imputed Log2FC merged\n n = ", dim(theImputedL2FC)[1]),
        xlab = "log2fc"
      )
    }
    
    hist(
      dflog2fcfinites$pvalue,
      breaks = 100,
      main = paste0("p-value distribution\n n = ", dim(dflog2fcfinites)[1]),
      xlab = "adj.pvalues"
    )
    hist(
      dflog2fcfinites$adj.pvalue,
      breaks = 100,
      main = paste0("Adjusted p-values distribution\n n = ", 
                    dim(dflog2fcfinites)[1]),
      xlab = "adj.pvalues"
    )
    hist(
      dflog2fcfinites$iLog2FC,
      breaks = 1000,
      main = paste0(
        "Non-imputed Log2FC distribution\n n = ",
        dim(dflog2fcfinites)[1]
      ),
      xlab = "log2FC"
    )
    hist(
      dflog2fc$iPvalue,
      breaks = 100,
      main = paste0(
        "(Imputed+NonImputed) adjusted pvalue distribution\n n = ",
        dim(dflog2fc)[1]
      ),
      xlab = "adj.pvalues"
    )
    hist(
      dflog2fc$iLog2FC,
      breaks = 1000,
      main = paste0(
        "(Imputed+NonImputed) log2fc distribution\n n = ",
        dim(dflog2fc)[1]
      ),
      xlab = "log2FC"
    )
    garbage <- dev.off()
  }
  
  
  # Relationship between conditions
  # Get the number of biological replicas based on the first condition
  theConditions <- unique(dfmq$GROUP_ORIGINAL)
  theFirstCond <- theConditions[2]
  condFirst <- dfmq[which(dfmq$GROUP_ORIGINAL == theFirstCond), ]
  theBiologicalReplicas <- unique(condFirst$SUBJECT_ORIGINAL)
  numberBioReplicas <- length(theBiologicalReplicas)
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # ABUNDANCE PLOTS
  
  if(plotAbundanceStats){
    if(verbose) message(">> PLOTS: ABUNDANCE PLOTS ")
    abundancesName <- gsub(".txt", ".relativeABUNDANCE.pdf", log2fc_file)
    abundancesName <- paste0("plot.", abundancesName)
    abundancesName <- paste0(output_dir, "/", abundancesName)
    pdf(abundancesName)
    .artms_plotAbundanceBoxplots(df = dfmq)
    .artms_plotNumberProteinsAbundance(df = dfmq)
    garbage <- dev.off()
  }
  
  # Reproducibility plots based on normalized abundance
  if(plotReproAbundance){
    if(verbose) message(">> PLOTS: REPRODUCIBILITY PLOTS ")
    reproName <- gsub(".txt", ".reproducibilityAbundance.pdf", log2fc_file)
    reproName <- paste0("plot.", reproName)
    reproName <- paste0(output_dir, "/", reproName)
    pdf(reproName)
    .artms_plotReproducibilityAbundance(dfmq, verbose = verbose)
    garbage <- dev.off()
  }
  
  # Conditions
  if(plotCorrConditions){
    if(verbose) message(">> PLOT: CORRELATION BETWEEN ALL COMPARISONS ")
    relaCond <- gsub(".txt", ".correlationConditions.pdf", log2fc_file)
    relaCond <- paste0("plot.", relaCond)
    relaCond <- paste0(output_dir, "/", relaCond)
    pdf(relaCond)
    .artms_plotCorrelationConditions(dfmq, numberBioReplicas)
    garbage <- dev.off()
  }
  
  if(plotCorrQuant){
    # Relationship between log2fc comparisons
    if(verbose) message(">> PLOT: CORRELATION BETWEEN QUANTIFICATIONS (based on log2fc values)")
    if (length(unique(dflog2fc$Label)) > 1) {
      relaChanges <- gsub(".txt", ".correlationQuantifications.pdf", log2fc_file)
      relaChanges <- paste0("plot.", relaChanges)
      relaChanges <- paste0(output_dir, "/", relaChanges)
      pdf(relaChanges)
      .artms_plotRatioLog2fc(dflog2fc, verbose = verbose)
      garbage <- dev.off()
    } else{
      if(verbose) message("--- Only one Comparison is available (correlation is not possible) ")
    }
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # ABUNDANCE DATA, CREATE FILTERS
  abundance <- .artms_loadModelqcBasic(dfmq)
  names(abundance)[grep('Protein', names(abundance))] <- 'Prey'
  names(abundance)[grep('Condition', names(abundance))] <- 'Bait'
  # TECHNICAL REPLICAS: if there are technical replicas means that we will find
  # two values for the same protein in the same bioreplica, therefore we need to
  # aggregate first just in case:
  abundance <- aggregate(Abundance ~ Prey + Bait + BioReplicate,
                         data = abundance,
                         FUN = mean)
  
  # Let's aggregate to get the sum of the abundance, we will use it later.
  abundance_dcsum <- data.table::dcast(abundance,
                                       Prey ~ Bait,
                                       value.var = 'Abundance',
                                       fun.aggregate = sum,
                                       fill = 0)
  abundance_dcmean <- data.table::dcast(abundance,
                                        Prey ~ Bait,
                                        value.var = 'Abundance',
                                        fun.aggregate = mean,
                                        fill = 0)
  
  # Melt again the sum and mean
  abundancelongsum <- data.table::melt(abundance_dcsum,
                                     id.vars = c('Prey'),
                                     value.name = 'Abundance',
                                     variable.name = 'Bait')
  
  abundancelongmean <- data.table::melt(abundance_dcmean,
                                      id.vars = c('Prey'),
                                      value.name = 'Abundance',
                                      variable.name = 'Bait')
  
  # We dont need the 0 values
  abundancelongsum <- abundancelongsum[!(abundancelongsum$Abundance == 0), ]
  abundancelongmean <- abundancelongmean[!(abundancelongmean$Abundance == 0), ]
  # Rename and merge:
  names(abundancelongsum)[grep('Abundance', names(abundancelongsum))] <- 'AbSum'
  names(abundancelongmean)[grep('Abundance', names(abundancelongmean))] <- 'AbMean'
  
  abundancelongsummean <- merge(abundancelongsum, abundancelongmean, by = c('Prey', 'Bait'))
  
  # REPRODUCIBILITY AND SPECIFICY PARATEMERS
  
  # Get the number of bioreplicates based on abundance data
  nbr_wide <- data.table::dcast(abundance,
                                Prey ~ Bait,
                                value.var = 'Abundance',
                                fun.aggregate = length,
                                fill = 0)
  nbr_long <- data.table::melt(nbr_wide,
                             id.vars = c('Prey'),
                             value.name = 'Abundance',
                             variable.name = 'Bait')
  
  nbr_long <- nbr_long[!(nbr_long$Abundance == 0), ]
  
  names(nbr_long)[grep('Abundance', names(nbr_long))] <- 'BioRep'
  
  # Get the number of replicates in long format
  OUTreprod <- data.table::dcast(data = nbr_long, Prey ~ Bait, value.var = 'BioRep')
  here <- dim(OUTreprod)[2]
  OUTreprod[is.na(OUTreprod)] <- 0
  # Make a copy to use later
  bioReplicaInfo <- OUTreprod
  # And get the total number of biological replicates
  OUTreprod$BiorepCount <- rowSums(OUTreprod[, 2:here])
  
  # Get whether a protein is found in all conditions
  reprospec2merge <- subset(OUTreprod, select = c(Prey, BiorepCount))
  
  OUTreproCondition <- data.table::dcast(data = nbr_long, Prey ~ Bait, value.var = 'BioRep')
  thedim <- dim(OUTreproCondition)[2]
  OUTreproCondition[is.na(OUTreproCondition)] <- 0
  thepreys <- subset(OUTreproCondition, select = c(Prey))
  thevalues <- subset(OUTreproCondition, select = -c(Prey))
  thevalues[thevalues > 0] <- 1
  thevalues$CondCount <- rowSums(thevalues)
  FinalReproCondition <- cbind(thepreys, thevalues)
  
  reprocondition2merge <- subset(FinalReproCondition, select = c(Prey, CondCount))
  
  # This version will be printed out below
  OUTreprodFinal <- merge(OUTreprod, reprocondition2merge, by = 'Prey')
  
  
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # PCA ANALYSIS
  # It requires a simplified version for modelqc
  if(plotPCAabundance){
    if(verbose) message(">> PRINCIPAL COMPONENT ANALYSIS BASED ON ABUNDANCE ")
    modelqcabundance <- .artms_loadModelQCstrict(df_input = dfmq,
                                                 species = species,
                                                 ptmis = isPtm,
                                                 verbose = verbose)
    out.pca <- gsub(".txt", "-pca", log2fc_file)
    out.pca <- paste0(output_dir, "/", out.pca)
    suppressWarnings(.artms_getPCAplots(modelqcabundance, out.pca, conditions))
  }
  
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # ANNOTATIONS
  modelqc_file_splc <- .artms_mergeAbNbr(dfmq, nbr_wide, species)
  
  if(verbose) message(">>> ANNOTATIONS ")
  # Now get ready for annotation
  if(verbose) message("--- Abundance data ")
  if (grepl("ptm", isPtm)) {
    names(modelqc_file_splc)[grep('^Protein$', names(modelqc_file_splc))] <- 'Uniprot_PTM'
    # Take the Protein ID, but being very careful about the fluomics labeling
    
    modelqc_file_splc <- .artmsExtractUniprotId(x = modelqc_file_splc, 
                                                uniprotPtmColumn = "Uniprot_PTM", 
                                                newColumnName = "Protein")
    suppressMessages(modelqc_file_splc <- artmsAnnotationUniprot(modelqc_file_splc, 'Protein', species))
  } else{
    suppressMessages(
      modelqc_file_splc <- artmsAnnotationUniprot(modelqc_file_splc, 'Protein', species)
    )
  }
  
  if(verbose) message("--- Relative Quantifications (Log2fc) ")
  # Prepare output of changes
  log2fc_file_splc <- .artms_mergeChangesNbr(dflog2fc, nbr_wide, species)
  # Now get ready for annotation
  if (grepl("ptm", isPtm)) {
    names(log2fc_file_splc)[grep('^Protein$', names(log2fc_file_splc))] <- 'Uniprot_PTM'
    # Take the Protein ID, but being very careful about the fluomics labeling
    log2fc_file_splc <- .artmsExtractUniprotId(x = log2fc_file_splc, 
                                               uniprotPtmColumn = "Uniprot_PTM", 
                                               newColumnName = "Protein")
    suppressMessages(
      log2fc_file_splc <- artmsAnnotationUniprot(log2fc_file_splc, 'Protein', species)
    )
  } else{
    suppressMessages(
      log2fc_file_splc <-
        artmsAnnotationUniprot(log2fc_file_splc, 'Protein', species)
    )
  }
  
  if(verbose) message(">> FILTERING CHANGES BEFORE PRINTING OUT ")
  
  imputedDF <- dflog2fc[c('Protein',
                          'Label',
                          'log2FC',
                          'pvalue',
                          'adj.pvalue',
                          'imputed',
                          'iLog2FC',
                          'iPvalue'
                          )]
    
    
  if(verbose) message("--- Merging Changes with bioReplica Info ")
  imputedDF <-
    merge(
      imputedDF,
      bioReplicaInfo,
      by.x = 'Protein',
      by.y = 'Prey',
      all.x = TRUE
    )
  
  if(verbose) message("--- Removing NA ")
    imputedDF <- imputedDF[!is.na(imputedDF$log2FC), ]
  
  if(verbose) message("--- Add labeling of condition more abundant in the quantification ")
  imputedDF$CMA <- mapply(.artms_selectTheOneLog2fc,
                          imputedDF$iLog2FC,
                          imputedDF$Label)
  
  if(verbose) message(
    "--- Removing proteins not found in a minimal number (",
    mnbr,
    ") of biological replicates "
  )
  
  imputedDF <- .artms_RemoveProtBelowThres(imputedDF, mnbr)
  
  if(verbose) message("--- Filtering is done! ")
  
  if(plotFinalDistributions){
    if(verbose) message(">> GENERATING QC PLOTS ABOUT CHANGES (log2fc) ")
    if(verbose) message("--- Distribution of log2fc and pvalues ")
    distributionsFilteredOut <- gsub(".txt", ".distributionsFil.pdf", log2fc_file)
    distributionsFilteredOut <- paste0(output_dir, "/", distributionsFilteredOut)
    pdf(distributionsFilteredOut)
    hist(imputedDF$iLog2FC,
         breaks = 1000,
         main = paste0("Filtered Log2FC (>2BR)\n n = ", dim(imputedDF)[1]),
         xlab = "log2fc")
    hist(imputedDF$iPvalue,
         breaks = 1000,
         main = paste0("Filtered p-values (>2BR)\n n = ", dim(imputedDF)[1]),
         xlab = "p-value")
    garbage <- dev.off()
  }
  
  if(plotPropImputation){
    if(verbose) message("--- Proportion imputed values ")
    # Stats about imputed values
    yesimputed <- dim(imputedDF[which(imputedDF$imputed == 'yes'), ])[1]
    nonimputed <- dim(imputedDF[which(imputedDF$imputed == 'no'), ])[1]
    
    dat <- data.frame(count = c(yesimputed, nonimputed),
                      category = c("Imputed", "Non-Imputed"))
    # Add addition columns, needed for drawing with geom_rect.
    dat$fraction = dat$count / sum(dat$count)
    dat <- dat[order(dat$fraction),]
    dat$ymax <- cumsum(dat$fraction)
    dat$ymin <- c(0, head(dat$ymax, n = -1))
    
    p1 <- ggplot(dat, aes(fill = category,
                          ymax = ymax,
                          ymin = ymin,
                          xmax = 4,
                          xmin = 3)) +
      geom_rect(na.rm = TRUE) +
      coord_polar(theta = "y") +
      xlim(c(0, 4)) +
      labs(title = "Proportion of Imputed Intensity values")
    p2 <- ggplot(dat, aes(x = category, y = count, fill = category)) +
      geom_bar(stat = "identity",
               na.rm = TRUE) +
      labs(title = "Proportion of Imputed Intensity values")
    
    outImputation <- gsub(".txt", ".imputation.pdf", log2fc_file)
    outImputation <- paste0(output_dir, "/", outImputation)
    pdf(outImputation)
    print(p1)
    print(p2)
    garbage <- dev.off()
  }
  
  if(plotHeatmapsChanges){
    if(verbose) message(">> HEATMAPS OF CHANGES (log2fc) ")
    l2fcol <- data.table::dcast(data = imputedDF, 
                                Protein ~ Label, 
                                value.var = 'iLog2FC')
    rownames(l2fcol) <- l2fcol$Protein
    l2fcol <- within(l2fcol, rm(Protein))
    l2fcol[is.na(l2fcol)] <- 0
    
    if (numberConditions > 1) {
      l2fcolmatrix <- data.matrix(l2fcol)
      if(verbose) message("--- All changes ")
      outHeatMapOverallL2fc <-
        gsub(".txt",
             ".clustering.log2fc.all-overview.pdf",
             log2fc_file)
      outHeatMapOverallL2fc <- paste0(output_dir, "/", outHeatMapOverallL2fc)
      pheatmap(
        l2fcolmatrix,
        filename = outHeatMapOverallL2fc,
        cellwidth = 20,
        main = "Clustering Log2FC",
        cluster_cols = FALSE,
        clustering_method = "average",
        fontfamily = "Helvetica",
        show_colnames = FALSE,
        fontsize = 6,
        fontsize_row = 3,
        fontsize_col = 10,
        border_color = NA
      )
      outHeatMapZoomL2fc <- gsub(".txt", ".clustering.log2fc.all-zoom.pdf", log2fc_file)
      outHeatMapZoomL2fc <- paste0(output_dir, "/", outHeatMapZoomL2fc)
      pheatmap(
        l2fcolmatrix,
        filename = outHeatMapZoomL2fc,
        cellheight = 10,
        cellwidth = 20,
        main = "Clustering Log2FC",
        cluster_cols = FALSE,
        fontsize = 6,
        fontsize_row = 8,
        fontsize_col = 8,
        border_color = NA,
        fontfamily = "Helvetica"
      )
      
      # Only significant pvalues
      if(verbose) message("--- Only significant changes ")
      imputedDFsig <- imputedDF[which(imputedDF$iPvalue < 0.05), ]
      l2fcolSignificants <- data.table::dcast(data = imputedDFsig, 
                                              Protein ~ Label, 
                                              value.var = 'iLog2FC')
      rownames(l2fcolSignificants) <- l2fcolSignificants$Protein
      l2fcolSignificants <- within(l2fcolSignificants, rm(Protein))
      l2fcolSignificants[is.na(l2fcolSignificants)] <- 0
      
      l2fcolSignificantsmatrix <- data.matrix(l2fcolSignificants)
      outHeatMapOverallL2fc <- gsub(".txt",
                                    ".clustering.log2fcSign.all-overview.pdf",
                                    log2fc_file)
      outHeatMapOverallL2fc <- paste0(output_dir, "/", outHeatMapOverallL2fc)
      pheatmap(
        l2fcolSignificantsmatrix,
        filename = outHeatMapOverallL2fc,
        cellwidth = 20,
        main = "Clustering Log2FC (p-value < 0.05)",
        cluster_cols = FALSE,
        fontfamily = "Helvetica",
        labels_row = "",
        fontsize = 6,
        fontsize_row = 8,
        fontsize_col = 8,
        border_color = NA,
        fontfamily = "Helvetica"
      )
      outHeatMapZoomL2fc <-
        gsub(".txt",
             ".clustering.log2fcSign.all-zoom.pdf",
             log2fc_file)
      outHeatMapZoomL2fc <- paste0(output_dir, "/", outHeatMapZoomL2fc)
      pheatmap(
        l2fcolSignificantsmatrix,
        filename = outHeatMapZoomL2fc,
        cellheight = 10,
        cellwidth = 20,
        main = "Clustering Log2FC (p-value < 0.05)",
        cluster_cols = FALSE,
        fontsize = 6,
        fontsize_row = 8,
        fontsize_col = 8,
        border_color = NA,
        fontfamily = "Helvetica"
      )
    }
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # ENRICHMENT OF MOST ABUNDANT PROTEINS (from IMPUTED LOG2FC values)
  # Let's select first significance based on pvalue, by using the iPvalue
  # we are already including the imputed pvalues...
  
  l2fcol4enrichment <- data.table::dcast(data = imputedDF[which(imputedDF$iPvalue < 0.05), ], 
                                         Protein ~ Label, 
                                         value.var = 'iLog2FC')
  
  if (enrich == TRUE & dim(l2fcol4enrichment)[1] > 0) {
    if(verbose) message(">> ENRICHMENT ANALYSIS OF SELECTED CHANGES USING GPROFILER ")
    
    if (dim(l2fcol4enrichment)[1] > 0) {
      # Let's melt now for enrichment analysis
      l2fcol4enrichment <- data.table::melt(data = l2fcol4enrichment,
                                          id.vars = c('Protein'),
                                          variable.name = "Comparisons")
      l2fcol4enrichment <- l2fcol4enrichment[complete.cases(l2fcol4enrichment), ]
      # Now get ready for annotation
      if (grepl("ptm", isPtm)) {
        names(l2fcol4enrichment)[grep('^Protein$', names(l2fcol4enrichment))] <- 'Uniprot_PTM'
        # Take the Protein ID, but being very careful about the fluomics labeling
        l2fcol4enrichment <- .artmsExtractUniprotId(x = l2fcol4enrichment, 
                                                    uniprotPtmColumn = "Uniprot_PTM", 
                                                    newColumnName = "Protein")
        suppressMessages(
          l2fcol4enrichment <- artmsAnnotationUniprot(l2fcol4enrichment, 
                                                      'Protein', 
                                                      species)
        )
      } else{
        suppressMessages(
          l2fcol4enrichment <- artmsAnnotationUniprot(l2fcol4enrichment, 
                                                      'Protein', 
                                                      species)
        )
      }
    }
    
    if (grepl("ptm", isPtm)) {
      # l2fcol4enrichment <- 
      # within(l2fcol4enrichment, rm(Gene,Uniprot_PTM,Protein.names))
      # # Remove parties for enrichment
      # l2fcol4enrichment <- l2fcol4enrichment[grep(",", l2fcol4enrichment$Protein, invert = TRUE),]
      # Select the Uniprot ID, but keep in mind that some of them might
      # have many _ph54_ph446 before
      # l2fcol4enrichment$Protein <- 
      # gsub("^(\\S+?)_.*", "\\1", l2fcol4enrichment$Protein, perl = TRUE)
      l2fcol4enrichment <- unique(l2fcol4enrichment[c("Protein", "Gene", "Comparisons", "value")])
    }
    
    # ALL SIGNIFICANT CHANGES log2fc
    # GPROFILER
    if(verbose) message("1) Enrichment of ALL significant Changes ")
    filallsig_log2fc_long <- l2fcol4enrichment[which(abs(l2fcol4enrichment$value) >= l2fc_thres),]
    
    if (dim(filallsig_log2fc_long)[1] > 0) {
      out.mac.allsig <- gsub(".txt", "-enrich-MAC-allsignificants.txt", log2fc_file)
      out.mac.allsig <- paste0(output_dir, "/", out.mac.allsig)
      mac.allsig <- NULL
      
      tryCatch(
        mac.allsig <- artmsEnrichLog2fc(
          dataset = filallsig_log2fc_long,
          output_name = out.mac.allsig,
          species = species,
          heatmaps = TRUE,
          background = listOfGenes,
          verbose = verbose
        ), error = function(e){
          message("\n\t(Error): Enrichment is not possible! ")
          message("\tgProfiler server night be down or your internet connection is not working")
          enrich <- FALSE
          }
      )
      
      if(!is.null(mac.allsig)){
        if (dim(mac.allsig)[1] > 0) {
          write.table(
            mac.allsig,
            out.mac.allsig,
            quote = FALSE,
            sep = "\t",
            row.names = FALSE,
            col.names = TRUE
          )
        }
      }

      
      if(verbose) message("---+ Corum Protein Complex Enrichment Analysis ")
      
      # CORUM
      allsigComplexEnriched <-
        .artms_enrichForComplexes(filallsig_log2fc_long, backgroundNumber)
      
      if (dim(allsigComplexEnriched)[1] > 0) {
        out.mac.allsig.corum <-
          gsub(".txt",
               "-enrich-MAC-allsignificants-corum.txt",
               log2fc_file)
        out.mac.allsig.corum <-
          paste0(output_dir, "/", out.mac.allsig.corum)
        write.table(
          allsigComplexEnriched,
          out.mac.allsig.corum,
          quote = FALSE,
          sep = "\t",
          row.names = FALSE,
          col.names = TRUE
        )
      }
      # And the heatmap
      if (dim(allsigComplexEnriched)[1] > 2) {
        out.mac.allsig.corum.pdf <-
          gsub(".txt",
               "-enrich-MAC-allsignificants-corum.pdf",
               log2fc_file)
        out.mac.allsig.corum.pdf <-
          paste0(output_dir, "/", out.mac.allsig.corum.pdf)
        .artms_plotCorumEnrichment(
          allsigComplexEnriched,
          out.mac.allsig.corum.pdf,
          "MAC ALL SIGNIFICANT Protein Complex Enrichment"
        )
      } else{
        message("--- (-) Not enough negative corum complexes to plot ")
      }
    } else{
      message(" ----(-) No significant hits ")
      mac.allsig <- NULL
      allsigComplexEnriched <- NULL
    }
    
    # POSITIVE log2fc
    # GPROFILER
    if(verbose) message("2) Enrichment of selected POSITIVE significant changes ")
    
    filpos_log2fc_long <-
      l2fcol4enrichment[which(l2fcol4enrichment$value >= l2fc_thres),]
    
    if (dim(filpos_log2fc_long)[1] > 0) {
      out.mac.pos <- gsub(".txt", "-enrich-MAC-positives.txt", log2fc_file)
      out.mac.pos <- paste0(output_dir, "/", out.mac.pos)

      mac.pos <- NULL
      tryCatch(
          mac.pos <- artmsEnrichLog2fc(
            dataset = filpos_log2fc_long,
            species = species,
            heatmaps = TRUE,
            output_name = out.mac.pos,
            background = listOfGenes,
            verbose = verbose
          ), error = function(e){
            message("\n\t(Error): Enrichment is not possible! ")
            message("\tgProfiler server night be down or your internet connection is not working")
            enrich = FALSE
          }
      )
      
      if(!is.null(mac.pos)){
        if (dim(mac.pos)[1] > 0) {
          write.table(
            mac.pos,
            out.mac.pos,
            quote = FALSE,
            sep = "\t",
            row.names = FALSE,
            col.names = TRUE
          )
        }
      }
      
      if(verbose) message("---+ Corum Protein Complex Enrichment Analysis ")
      
      # CORUM
      positiveComplexEnriched <-
        .artms_enrichForComplexes(filpos_log2fc_long, backgroundNumber)
      
      if (dim(positiveComplexEnriched)[1] > 0) {
        out.mac.pos.corum <-
          gsub(".txt",
               "-enrich-MAC-positives-corum.txt",
               log2fc_file)
        out.mac.pos.corum <-
          paste0(output_dir, "/", out.mac.pos.corum)
        write.table(
          positiveComplexEnriched,
          out.mac.pos.corum,
          quote = FALSE,
          sep = "\t",
          row.names = FALSE,
          col.names = TRUE
        )
      }
      
      # And the heatmap
      if (dim(positiveComplexEnriched)[1] > 2) {
        out.mac.pos.corum.pdf <-
          gsub(".txt",
               "-enrich-MAC-positives-corum.pdf",
               log2fc_file)
        out.mac.pos.corum.pdf <-
          paste0(output_dir, "/", out.mac.pos.corum.pdf)
        # out.mac.pos.corum.pdf <- 'whatever.corum.positive.pdf'
        .artms_plotCorumEnrichment(
          positiveComplexEnriched,
          out.mac.pos.corum.pdf,
          "MAC+ Protein Complex Enrichment"
        )
      } else{
        if(verbose) message("\t----(-) Not enough positive corum complexes to plot ")
      }
    } else{
      if(verbose) message("\t ------ Nothing is significant in the selected Positive log2fc ")
      mac.pos <- NULL
      positiveComplexEnriched <- NULL
    }
    
    
    # NEGATIVE log2fc
    if(verbose) message("3) Enrichment of selected NEGATIVE significant changes ")
    
    filneg_log2fc_long <-
      l2fcol4enrichment[which(l2fcol4enrichment$value <= -l2fc_thres),]
    
    if (dim(filneg_log2fc_long)[1] > 0) {
      out.mac.neg <- gsub(".txt", "-enrich-MAC-negatives.txt", log2fc_file)
      out.mac.neg <- paste0(output_dir, "/", out.mac.neg)
      
      mac.neg <- NULL
      tryCatch(
        mac.neg <- artmsEnrichLog2fc(
          dataset = filneg_log2fc_long,
          output_name = out.mac.neg,
          species = species,
          heatmaps = TRUE,
          background = listOfGenes,
          verbose = verbose), 
        error = function(e){
          message("\n\t(Error): Enrichment is not possible! ")
          message("\tgProfiler server night be down or your internet connection is not working")
          enrich <- FALSE
        })
      
      if(!is.null(mac.neg)){
        if (dim(mac.neg)[1] > 0) {
          write.table(
            mac.neg,
            out.mac.neg,
            quote = FALSE,
            sep = "\t",
            row.names = FALSE,
            col.names = TRUE
          )
        }
      }
      
      if(verbose) message("---+ Corum Protein Complex Enrichment Analysis ")
      
      negativesComplexEnriched <- .artms_enrichForComplexes(filneg_log2fc_long, backgroundNumber)
        
      
      if (dim(negativesComplexEnriched)[1] > 0) {
        out.mac.neg.corum <- gsub(".txt",
                                  "-enrich-MAC-negatives-corum.txt",
                                  log2fc_file)
          
        out.mac.neg.corum <- paste0(output_dir, "/", out.mac.neg.corum)
        write.table(
          negativesComplexEnriched,
          out.mac.neg.corum,
          quote = FALSE,
          sep = "\t",
          row.names = FALSE,
          col.names = TRUE
        )
      }
      
      # And the heatmap
      if (dim(negativesComplexEnriched)[1] > 2) {
        out.mac.neg.corum.pdf <- gsub(".txt",
                                      "-enrich-MAC-negatives-corum.pdf",
                                      log2fc_file)
          
        out.mac.neg.corum.pdf <- paste0(output_dir, "/", out.mac.neg.corum.pdf)
        .artms_plotCorumEnrichment(negativesComplexEnriched,
                                   out.mac.neg.corum.pdf,
                                   "MAC- Protein Complex Enrichment")
          
      } else{
        if(verbose) message("\t-----(-) Not enough negative corum complexes to plot ")
      }
    } else{
      if(verbose) message("\t------ Nothing is significant in the NEGATIVE site of things ")
      mac.neg <- NULL
      negativesComplexEnriched <- NULL
    }
  } else{
    if(verbose) message(">> NO ENRICHMENT of CHANGES (log2fc) SELECTED ")
  }
  # END enrichments
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  superunified <- merge(abundancelongsummean,
                        nbr_long,
                        by = c('Bait', 'Prey'),
                        all = TRUE)
  superunified <- merge(superunified,
                        reprocondition2merge,
                        by = 'Prey',
                        all = TRUE)
  superunified <- merge(superunified,
                        reprospec2merge,
                        by = 'Prey',
                        all = TRUE)
  
  if (grepl("ptm", isPtm)) {
    names(superunified)[grep('^Prey$', names(superunified))] <- 'Uniprot_PTM'
    # Take the Protein ID, but being very careful about the fluomics labeling
    superunified <- .artmsExtractUniprotId(x = superunified, 
                                           uniprotPtmColumn = "Uniprot_PTM", 
                                           newColumnName = "Prey")
  }
  
  suppressMessages(superunified <- artmsAnnotationUniprot(superunified, 'Prey', species))
  
  # Rename (before it was just a lazy way to use another code)
  names(superunified)[grep('Bait', names(superunified))] <- 'Condition'
  
  # ANNOTATE SPECIE
  if(verbose) message("--- Annotating species(s) in files ")
  superunified <- artmsAnnotateSpecie(superunified, pathogen, species)
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # THE JITTER PLOTS
  
  if (isFluomics == TRUE) {
    if(verbose) message(">> JITTERED PLOT ")
    # Filter by number of biological replicas > 1
    superunifiedfiltered <-
      superunified[which(superunified$BioRep > 1), ]
    # Filter less than
    superunifiedfiltered <-
      superunifiedfiltered[which(superunifiedfiltered$AbMean < 30 &
                                   superunifiedfiltered$AbMean > 10),]
    # Removing carry overs
    superunifiedfiltered <-
      superunifiedfiltered[!(
        grepl("H1N1|H3N2|H5N1", superunifiedfiltered$Protein) &
          grepl("MOCK", superunifiedfiltered$Condition)
      ), ]
    
    abuJittered <- gsub(".txt", ".abundanceGrouped.pdf", log2fc_file)
    abuJittered <- paste0("plot.", abuJittered)
    abuJittered <- paste0(output_dir, "/", abuJittered)
    # j <- ggplot(superunifiedfiltered %>% arrange(Species), 
    # aes(Condition,AbMean))
    # j <- j + geom_jitter(aes(colour = Species), width = 0.3)
    if (species == "human") {
      j <- ggplot(superunifiedfiltered %>% arrange(desc(Species)),
                  aes(
                    x = Condition,
                    y = AbMean,
                    colour = Species
                  )) #superunifiedfiltered %>% arrange(Species)
      j <- j + geom_jitter(width = 0.3, na.rm = TRUE)
      j <- j + scale_colour_manual(values = c("red", "lightblue"))
    } else if (species == "mouse") {
      j <- ggplot(superunifiedfiltered %>% arrange(Species),
                  aes(Condition, AbMean))
      j <- j + geom_jitter(aes(colour = Species), width = 0.3, na.rm = TRUE)
      j <- j + scale_colour_manual(values = c("azure3", "red"))
    }
    j <- j + theme_minimal()
    j <- j + theme(axis.text.x = element_text(angle = 90,
                                              hjust = 1,
                                              vjust = 0.5))
    pdf(abuJittered)
      print(j)
    garbage <- dev.off()
    if(verbose) message("--- done ")
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if (grepl("ptm", isPtm)) {
    if(verbose) message(">> GENERATING EXTENDED DETAILED VERSION OF PH-SITE ")
    imputedDFext <- artmsGeneratePhSiteExtended(df = imputedDF,
                                                pathogen = pathogen,
                                                species = species,
                                                ptmType = isPtm,
                                                output_name = paste0(output_dir, "/", log2fc_file))
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if(verbose) message(">> GENERATING FINAL OUTPUT FILES ")
  if (grepl("ptm", isPtm)) {
    names(imputedDF)[grep('Protein', names(imputedDF))] <- 'Uniprot_PTM'
    imputedDF$UniprotID <- imputedDF$Uniprot_PTM
    # The virus labeling has to be taken into account 
    # when getting the uniprot id:
    imputedDF <- .artmsExtractUniprotId(x = imputedDF, 
                                        uniprotPtmColumn = "Uniprot_PTM", 
                                        newColumnName = "UniprotID")
    suppressMessages(imputedDF <- artmsAnnotationUniprot(imputedDF, 
                                                         'UniprotID', 
                                                         species))
    names(imputedDF)[grep("Label", names(imputedDF))] <- 'Comparison'
    
    imputedDF <- artmsAnnotateSpecie(imputedDF, pathogen, species)
    
    # Wide version of imputedDF
    imputedDF_wide_log2fc <-
      data.table::dcast(
        data = imputedDF,
        Gene + Protein + EntrezID + Uniprot_PTM ~ Comparison,
        value.var = 'iLog2FC',
        fill = 0
      )
    imputedDF_wide_pvalue <-
      data.table::dcast(
        data = imputedDF,
        Gene + Protein + EntrezID + Uniprot_PTM ~ Comparison,
        value.var = 'iPvalue',
        fill = 0
      )
    
  } else if (isPtm == "global") {
    suppressMessages(imputedDF <- artmsAnnotationUniprot(imputedDF, 
                                                         'Protein', 
                                                         species))
    names(imputedDF)[grep("Label", names(imputedDF))] <- 'Comparison'
    
    imputedDF <- artmsAnnotateSpecie(imputedDF, pathogen, species)
    
    # Wide version of imputedDF
    imputedDF_wide_log2fc <-
      data.table::dcast(
        data = imputedDF,
        Gene + Protein + EntrezID ~ Comparison,
        value.var = 'iLog2FC',
        fill = 0
      )
    imputedDF_wide_pvalue <-
      data.table::dcast(
        data = imputedDF,
        Gene + Protein + EntrezID ~ Comparison,
        value.var = 'iPvalue',
        fill = 0
      )
  } else{
    stop(" WRONG isPTM SELECTED. 
         OPTIONS AVAILABLE: global, ptmph, ptmsites ")
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # boxplot of relative quantifications
  if(plotTotalQuant){
    if(verbose) message(">> PLOT OUT: TOTAL NUMBER OF PROTEINS/SITES QUANTIFIED")
    numimputedfinal <- gsub(".txt", ".TotalQuantifications.pdf", log2fc_file)
    numimputedfinal <- paste0("plot.", numimputedfinal)
    numimputedfinal <- paste0(output_dir, "/", numimputedfinal)
    pdf(numimputedfinal)
    .artms_plotNumberProteinsImputedLog2fc(imputedDF)
    garbage <- dev.off()
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if(plotClusteringAnalysis){
    if (isPtm == "global") {
      if(verbose) message(">> CLUSTERING ANALYSIS OF QUANTIFICATIONS ")
      
      # PRE-CLUSTERING
      # GET THE LIST OF SIGNIFICANTS FOR THE EXPERIMENT(S)
      list_of_significants <-
        unique(imputedDF$Protein[which(abs(imputedDF$iLog2FC > 1) &
                                         imputedDF$iPvalue < 0.05)])
      
      # AND APPLY THE FILTER
      data.select <-
        imputedDF[which(imputedDF$Protein %in% list_of_significants), ]
      
      # GENE BASED -> heatmaps
      hasdc <-
        data.table::dcast(
          data = data.select[which(data.select$imputed == "no"), ],
          Gene + Protein ~ Comparison,
          value.var = "iLog2FC",
          fun.aggregate = median,
          fill = 0
        )
      
      # EXPERIMENT BASED -> PCA
      hasdcexp <-
        data.table::dcast(
          data = data.select[which(data.select$imputed == "no"), ],
          Comparison ~ Gene + Protein,
          value.var = "iLog2FC",
          fun.aggregate = median,
          fill = 0
        )
    
      # CLUSTERING ANALYSIS
      # GENE BASED
      rownames(hasdc) <- paste0(hasdc$Gene, "_", hasdc$Protein)
      vamos <- within(hasdc, rm(Gene, Protein))
      
      # if this dataset only have one comparison,
      # this analysis does not makes sense: check it out:
      if (dim(vamos)[2] > 1) {
        venga <- as.matrix(vamos)
        
        # EXPERIMENT BASED
        rownames(hasdcexp) <- hasdcexp$Comparison
        vamosexp <- within(hasdcexp, rm(Comparison))
        vengaexp <- as.matrix(vamosexp)
        
        # PCA AND CORRELATION ANALYSIS
        if(verbose) message("--- Correlation plots ")
        df.cor.matrix <- round(cor(venga, use = "pairwise.complete.obs"), 2)
        file_corr_l2fc <- gsub(".txt", ".log2fc-corr.pdf", log2fc_file)
        file_corr_l2fc <- paste0(output_dir, "/", file_corr_l2fc)
        pdf(file_corr_l2fc, width = 12, height = 9)
        corrplot::corrplot(
          df.cor.matrix,
          type = "upper",
          tl.pos = "td",
          method = "circle",
          tl.cex = 0.9,
          tl.col = 'black',
          tl.srt = 45,
          # order = "hclust",
          diag = TRUE
        )
        PerformanceAnalytics::chart.Correlation(venga,
                                                histogram = TRUE,
                                                pch = 25,
                                                main = "Correlation between Comparisons")
        garbage <- dev.off()
        
        # BASED ON GROUPS
        pca.hasdcexp <- FactoMineR::PCA(
          hasdcexp[, -c(1)],
          scale.unit = FALSE,
          ncp = 4,
          graph = FALSE
        )
        
        pca_all <- factoextra::fviz_pca_ind(pca.hasdcexp,
                                            labelsize = 3,
                                            repel = TRUE,
                                            habillage = as.factor(hasdcexp$Comparison),
                                            addEllipses = FALSE,
                                            ellipse.level = 0.95
                                            )
          
        
        if(verbose) message("--- PCA, individuals plot ")
        file_pca_l2fc <- gsub(".txt", ".log2fc-individuals-pca.pdf", log2fc_file)
        file_pca_l2fc <- paste0(output_dir, "/", file_pca_l2fc)
        pdf(file_pca_l2fc, width = 9, height = 7)
        print(pca_all)
        garbage <- dev.off()
        
        # Determine the OPTIMAL NUMBER OF CLUSTERS:
        
        # Elbow method
        e1 <- factoextra::fviz_nbclust(venga, kmeans, method = "wss") +
          geom_vline(xintercept = 4, linetype = 2) +
          labs(subtitle = "kmeans Elbow method")
          
        e2 <- factoextra::fviz_nbclust(venga, cluster::pam, method = "wss") +
          geom_vline(xintercept = 4, linetype = 2) +
          labs(subtitle = "PAM Elbow method")
          
        
        # Silhouette method
        k1 <- factoextra::fviz_nbclust(venga, kmeans, method = "silhouette") +
          labs(subtitle = "kmeans Silhouette method")
          
        k2 <- factoextra::fviz_nbclust(venga, cluster::pam, method = "silhouette") +
          labs(subtitle = "pam Silhouette method")
          
        # Create a dendrogram
        if(verbose) message("--- Dendrogram ")
        res.dist <- factoextra::get_dist(vamosexp, stand = TRUE, method = "minkowski")
        hc <- hclust(res.dist)
        file_dendro_l2fc <- gsub(".txt", ".log2fc-dendro.pdf", log2fc_file)
        file_dendro_l2fc <- paste0(output_dir, "/", file_dendro_l2fc)
        pdf(file_dendro_l2fc, width = 9, height = 7)
        plot(hc)
        garbage <- dev.off()
        
        # COMPLEXHEATMAP Heatmap with a specified number of optimal clusters
        n = 10
        pam.res <- pam(vamos, k = n)
        
        cp1 <- factoextra::fviz_cluster(pam.res)
        cp2 <- factoextra::fviz_silhouette(pam.res, print.summary = FALSE)
        
        if(verbose) message("--- Plots to determine optimal number of clusters ")
        file_clusterplots_l2fc <- gsub(".txt", ".log2fc-clusters.pdf", log2fc_file)
          
        file_clusterplots_l2fc <- paste0(output_dir, "/", file_clusterplots_l2fc)
          
        pdf(file_clusterplots_l2fc,
            width = 9,
            height = 7)
          print(e1)
          print(e2)
          print(k1)
          print(k2)
          print(cp1)
          print(cp2)
        garbage <- dev.off()
        
        if(verbose) message("--- Cluster heatmaps (10 clusters) ")
        
        hmap <- ComplexHeatmap::Heatmap(venga,
                                        name = paste0("Clusters ", "(n = ", n, ")"),
                                        col = circlize::colorRamp2(c(-3, 0, 3), c("firebrick1", "black", "olivedrab1")),
                                        heatmap_legend_param = list(color_bar = "continuous",
                                                                    legend_direction = "horizontal",
                                                                    legend_width = unit(5, "cm"),
                                                                    title_position = "topcenter",
                                                                    title_gp = gpar(fontsize = 15, fontface = "bold")),
                                        split = paste0("", pam.res$clustering),
                                        row_title = "Genes",
                                        row_title_side = "left",
                                        row_title_gp = gpar(fontsize = 15, fontface = "bold"),
                                        show_row_names = FALSE,
                                        column_title = "Relative Quantifications",
                                        column_title_side = "top",
                                        column_title_gp = gpar(fontsize = 10, fontface = "bold"),
                                        column_title_rot = 0,
                                        show_column_names = TRUE,
                                        cluster_columns = FALSE,
                                        clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
                                        clustering_method_columns = "ward.D2",
                                        clustering_distance_rows = "euclidean",
                                        clustering_method_rows = "ward.D2",
                                        row_dend_width = unit(30, "mm"),
                                        column_dend_height = unit(30, "mm"),
                                        # top_annotation=colAnn,
                                        # top_annotation_height = unit(1.75, "cm"),
                                        # bottom_annotation=sampleBoxplot,
                                        # bottom_annotation_height = unit(4, "cm"),
                                        column_names_gp = gpar(fontsize = 10)
                                        )
          
        file_clusterheat_l2fc <- gsub(".txt", ".log2fc-clusterheatmap.pdf", log2fc_file)
        file_clusterheat_l2fc <- paste0(output_dir, "/", file_clusterheat_l2fc)
        pdf(file_clusterheat_l2fc,
            width = 12,
            height = 10)
        ComplexHeatmap::draw(hmap,
                             heatmap_legend_side = "top",
                             annotation_legend_side = "right")
        garbage <- dev.off()
        
        # Pre enrichment of clusters
        cl_number <- pam.res$clustering
        dfclusters <- as.data.frame(cl_number)
        dfclusters$ids <- row.names(dfclusters)
        dfclusters$Gene <- gsub("(.*)(_)(.*)", "\\1", dfclusters$ids)
        dfclusters$Protein <- gsub("(.*)(_)(.*)", "\\3", dfclusters$ids)
        
        if(enrich){
          if(verbose) message("--- Enrichment analysis of the clusters ")
          # Making sure we have unique genes in each comparison 
          # (the PTM might bring redundancy)
          pretmp <- dfclusters[c('Gene', 'cl_number')]
          pretmp <- unique(pretmp)
          
          tmp <- split(pretmp$Gene, pretmp$cl_number, drop = TRUE)
          enrichgenes <- NULL
          
          if (species == "human") {
            tryCatch(enrichgenes <- artmsEnrichProfiler(tmp,
                                                        categorySource = c(
                                                          'GO:BP',
                                                          'GO:MF',
                                                          'GO:CC',
                                                          'KEGG',
                                                          'REAC',
                                                          'CORUM',
                                                          'HPA',
                                                          'OMIM'
                                                        ),
                                                        species = 'hsapiens',
                                                        listOfGenes,
                                                        verbose = verbose), 
                     error = function(e){
                       message("\n\t(Error): Enrichment is not possible! ")
                       message("\tgProfiler server night be down or your internet connection is not working")
                       enrich <- FALSE
                     }
                     )

          } else if (species == "mouse") {
            tryCatch(enrichgenes <- artmsEnrichProfiler(tmp,
                                                        categorySource = c('GO:BP', 
                                                                           'GO:MF', 
                                                                           'GO:CC', 
                                                                           'KEGG', 
                                                                           'REAC', 
                                                                           'CORUM'),
                                                        species = 'mmusculus',
                                                        listOfGenes,
                                                        verbose = verbose),
                     error = function(e){
                       message("\n\t(Error): Enrichment is not possible! ")
                       message("\tgProfiler server night be down or your internet connection is not working")
                       enrich <- FALSE
                     }
                     )
          } else{
            stop(species, " is currently not supported in the enrichment")
          }
          
          # Write the file
          if(!is.null(enrichgenes)){
            file_clusterheatenrich_l2fc <- gsub(".txt",
                                                ".log2fc-clusterheatmap-enriched.txt",
                                                log2fc_file)
            
            file_clusterheatenrich_l2fc <- paste0(output_dir, "/", file_clusterheatenrich_l2fc)
            write.table(enrichgenes,
                        file_clusterheatenrich_l2fc,
                        col.names = TRUE,
                        row.names = FALSE,
                        sep = "\t",
                        quote = FALSE)
          }
        } #if enrich = TRUE
        
        # Print out clusters
        file_clusterheatdata_l2fc <- gsub(".txt", ".log2fc-clusterheatmap.txt", log2fc_file)
        file_clusterheatdata_l2fc <- paste0(output_dir, "/", file_clusterheatdata_l2fc)
        write.table(
          dfclusters,
          file_clusterheatdata_l2fc,
          col.names = TRUE,
          row.names = FALSE,
          sep = "\t",
          quote = FALSE
        )
      }
    }
  }
  # End of clustering analysis
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  if(verbose) message(">> WRITING THE OUTPUT FILES")
  
  # PRINT OUT IMPUTED
  outlog2fcImpute <- gsub(".txt", "-log2fc-long.txt", log2fc_file)
  outlog2fcImpute <- paste0(output_dir, "/", outlog2fcImpute)
  write.table(
    imputedDF,
    outlog2fcImpute,
    quote = FALSE,
    sep = "\t",
    row.names = FALSE,
    col.names = TRUE
  )
  
  outlog2fc <- gsub(".txt", "-log2fc-wide.txt", log2fc_file)
  outlog2fc <- paste0(output_dir, "/", outlog2fc)
  write.table(
    log2fc_file_splc,
    outlog2fc,
    quote = FALSE,
    sep = "\t",
    row.names = FALSE,
    col.names = TRUE
  )
  
  outexcel <- gsub(".txt", "-summary.xlsx", log2fc_file)
  outexcel <- paste0(output_dir, "/", outexcel)
  
  if(is.null(mac.allsig) | is.null(mac.pos) | is.null(mac.neg))
    enrich <- FALSE
  
  if (enrich) {
    # But now check whether is a PTM case:
    if (grepl("ptm", isPtm)) {
      list_of_datasets <- list(
        "log2fcImputed" = imputedDF,
        "log2fcImpExt" = imputedDFext,
        "wide_iLog2fc" = imputedDF_wide_log2fc,
        "wide_iPvalue" = imputedDF_wide_pvalue,
        "enrichALL" = mac.allsig,
        "enrichMACpos" = mac.pos,
        "enrichMACneg" = mac.neg,
        "enMACallCorum" = allsigComplexEnriched,
        "enMACposCorum" = positiveComplexEnriched,
        "enMACnegCorum" = negativesComplexEnriched
      )
    } else if (grepl("global", isPtm)) {
      list_of_datasets <- list(
        "log2fcImputed" = imputedDF,
        "wide_iLog2fc" = imputedDF_wide_log2fc,
        "wide_iPvalue" = imputedDF_wide_pvalue,
        "enrichALL" = mac.allsig,
        "enrich-MACpos" = mac.pos,
        "enrich-MACneg" = mac.neg,
        "enMACallCorum" = allsigComplexEnriched,
        "enMACposCorum" = positiveComplexEnriched,
        "enMACnegCorum" = negativesComplexEnriched
      )
      
    } else{
      stop("Wrong option:", isPtm)
    }
  } else if (!enrich) {
    if (grepl("ptm", isPtm)) {
      list_of_datasets <- list(
        "log2fcImputed" = imputedDF,
        "log2fcImpExt" = imputedDFext,
        "wide_iLog2fc" = imputedDF_wide_log2fc,
        "wide_iPvalue" = imputedDF_wide_pvalue
      )
    } else if (grepl("global", isPtm)) {
      list_of_datasets <- list(
        "log2fcImputed" = imputedDF,
        "wide_iLog2fc" = imputedDF_wide_log2fc,
        "wide_iPvalue" = imputedDF_wide_pvalue
      )
    } else{
      stop(isPtm, " is not a valid option")
    }
  } else{
    stop("Contact developers")
    # The script should have crashed by this point. 
    # If it gets up to here... it would be very weird
  }
  
  # Defining style for the header
  hs <- openxlsx::createStyle(fontName = "Arial",
                              fontColour = "white",
                              fgFill = "#000000",
                              textDecoration = "Bold",
                              border = "Bottom")
  openxlsx::write.xlsx(
    list_of_datasets,
    file = outexcel,
    asTable = FALSE,
    headerStyle = hs
  )
  
  if(verbose) message("Folder <", output_dir, "> ")
  if(verbose) message("- EXCEL: ", outexcel, " ")
  if(verbose) message("- Log2fc Wide: ", outlog2fc, " ")
  if(verbose) message("- Log2fc Impute: ", outlog2fc, " ")
  
  if (enrich == TRUE) {
    if(verbose) message("- ENRICHMENT files should also be out ")
  }
  
  if(verbose) message(">> SUPER ANALYSIS COMPLETED")
}


# ------------------------------------------------------------------------------
#' @title Adding a column with the species name
#'
#' @description Adding the species name to every protein.
#' This makes more sense if there are more than one species in the dataset,
#' which must be specified in the `pathogen` option. Influenza is a special
#' case that it does not need to be specified, as far as the proteins were
#' originally annotated as `INFLUENZAGENE_STRAIN`
#' (strains covered `H1N1`, `H3N2`, `H5N1`), as for example, `NS1_H1N1`
#' @param df (data.frame) with a `Protein` column (of uniprot ids)
#' @param pathogen (char) Is there a pathogen in the dataset as well?
#' if it does not, then use `pathogen = nopathogen` (default). Supported`tb` 
#' (Tuberculosis),
#' `lpn` (Legionella)
#' @param species (char) Host organism (supported for now: `human` or `mouse`)
#' @return (data.frame) The same data.frame but with an extra column 
#' specifying the species
#' @keywords annotation, species
#' @examples
#' # Adding a new column with the main species of the data. Easy.
#' # But the main functionality is to add both the host-species and a pathogen,
#' # which is not illustrated in this example
#' data_with_specie <- artmsAnnotateSpecie(df = artms_data_ph_msstats_results,
#'                                          species = "human")
#' @export
artmsAnnotateSpecie <- function(df,
                                 pathogen = "nopathogen",
                                 species) {
  
  if(any(missing(df) | missing(species)))
    stop("Missed (one or many) required argument(s).
         Please, check the help of this function to find out more")
  
  if (pathogen == "nopathogen") {
    # Influenza is treated differently
    df$Species <-
      ifelse(grepl("_H1N1|_H3N2|_H5N1", df$Protein),
             "Influenza",
             species)
  } else if (pathogen == "tb") {
    pathogen.ids <- artms_data_pathogen_TB
    df$Species <-
      ifelse(df$Protein %in% pathogen.ids$Entry, pathogen, species)
  } else if (pathogen == "lpn") {
    pathogen.ids <- artms_data_pathogen_LPN
    df$Species <-
      ifelse(df$Protein %in% pathogen.ids$Entry, pathogen, species)
  }
  return(df)
}

# ------------------------------------------------------------------------------
#' @title Generate ph-site specific detailed file
#'
#' @description Generate extended detailed ph-site file, where every line is a
#' ph site instead of a peptide. Therefore, if one peptide has multiple ph sites
#' it will be breaking down in each of the sites. This file will help generate
#' input files for tools as [Phosfate](http://phosfate.com/) or
#' [PHOTON](https://github.com/jdrudolph/photon)
#' @param df (data.frame) of log2fc and imputed values
#' @param pathogen (char) Is there a pathogen in the dataset as well? Available
#' pathogens are `tb` (Tuberculosis), `lpn` (Legionella). If it is not,
#' then use `nopathogen` (default).
#' @param species (char) Main organism (supported for now: `human` or `mouse`)
#' @param ptmType (char) It must be a ptm-site quantification dataset. Either:
#' yes: `ptmsites` (for site specific analysis), or
#' `ptmph` (Jeff's script output evidence file).
#' @param output_name (char) A output file name (extension `.txt` required)
#' @return (data.frame) extended version of the ph-site
#' @keywords external, tools, phosfate
#' @examples \donttest{
#' artmsGeneratePhSiteExtended(df = dfobject, 
#'                              species = "mouse", 
#'                              ptmType = "ptmsites",
#'                              output_name = log2fc_file)
#' }
#' @export
artmsGeneratePhSiteExtended <- function(df, 
                                         pathogen = "nopathogen", 
                                         species, 
                                         ptmType,
                                         output_name) {
  
  if(any(missing(df) | 
         missing(species) | 
         missing(ptmType) | 
         missing(output_name)))
    stop("Missed (one or many) required argument(s)
         Please, check the help of this function to find out more")
    
    imputedDFext <- NULL
    
    imputedDFext <- .artms_checkIfFile(input_file = df)
    
    if (ptmType == "ptmph") {
      # Change the Protein name to Uniprot_PTM (if it is not there already)
      if(!any(grepl("Uniprot_PTM", colnames(imputedDFext)))) 
        names(imputedDFext)[grep('^Protein$', names(imputedDFext))] <- 'Uniprot_PTM'
      
      # Take the Protein ID, but being very careful about the fluomics labeling
      imputedDFext <- 
        .artmsExtractUniprotId(x = imputedDFext, 
                               uniprotPtmColumn = "Uniprot_PTM", 
                               newColumnName = "Protein")
      
      # Extract sites from Uniprot_PTM
      imputedDFext$PTMsite <-
        gsub("^(\\S+?)(_ph.*)", "\\2", imputedDFext$Uniprot_PTM, perl = TRUE)
      imputedDFext$PTMsite <- gsub("^(_ph)", "", imputedDFext$PTMsite)
      imputedDFext$PTMsite <- gsub("_ph", ",", imputedDFext$PTMsite)
      
      # And create independent columns for each of them
      imputedDFext <-
        imputedDFext %>% mutate(PTMsite = strsplit(PTMsite, ",")) %>% tidyr::unnest(PTMsite)
      
      if( !any(grepl("Gene", colnames(imputedDFext))) ) suppressMessages(
        imputedDFext <- artmsAnnotationUniprot(imputedDFext, 
                                                'Protein', 
                                                species)
        )
      
      if( any(grepl("Label", colnames(imputedDFext))) )
      names(imputedDFext)[grep("^Label$", names(imputedDFext))] <-
        'Comparison'
      
      imputedDFext <- artmsAnnotateSpecie(imputedDFext, pathogen, species)
    } else if (ptmType == "ptmsites") {
      #1. Change the Protein name to Uniprot_PTM (if it is not there already)
      if(!any(grepl("Uniprot_PTM", colnames(imputedDFext)))) 
        names(imputedDFext)[grep('^Protein$', names(imputedDFext))] <- 
        'Uniprot_PTM'
      
      # 2. Make a copy of Uniprot_PTM to operate on it
      imputedDFext$PTMone <- imputedDFext$Uniprot_PTM
      
    # 3. Create independent columns for each of them
    imputedDFext <-
      imputedDFext %>% dplyr::mutate(
        PTMone = strsplit(PTMone, ",")) %>% tidyr::unnest(PTMone)
      
      # 4. And take the labels:
      imputedDFext$Protein <-
        ifelse(
          grepl("_H1N1|_H3N2|_H5N1", imputedDFext$PTMone),
          gsub("^(\\S+?_H[1,3,5]N[1,2])_.*", "\\1",
               imputedDFext$PTMone, perl = TRUE
          ) ,
          gsub("^(\\S+?)_.*", "\\1", imputedDFext$PTMone, perl = TRUE)
        )
      imputedDFext$PTMaa <-
        gsub("(\\S+)(_)([S,T,Y,K])(\\d+)", "\\3", imputedDFext$PTMone)
      imputedDFext$PTMsite <-
        gsub("(\\S+)(_)([S,T,Y,K])(\\d+)", "\\4", imputedDFext$PTMone)
      
      imputedDFext$PTMone <- NULL
      
      if( !any(grepl("Gene", colnames(imputedDFext))) ) suppressMessages(
        imputedDFext <- 
          artmsAnnotationUniprot(imputedDFext, 'Protein', species)
      )
      
      if( any(grepl("Label", colnames(imputedDFext))) )
      names(imputedDFext)[grep("^Label$", names(imputedDFext))] <-
        'Comparison'
      
      # imputedDFext$Species <- ifelse(grepl("_H1N1|_H3N2|_H5N1", 
      # imputedDFext$Protein), "Influenza", species)
      # imputedDFext$Species <- ifelse(imputedDFext$Protein 
      # %in% pathogen.ids$Entry, pathogen, species)
      
      if( !any(grepl("Species", colnames(imputedDFext))) ) suppressMessages(
        imputedDFext <-
                      artmsAnnotateSpecie(imputedDFext, "Protein", species))
    } else{
      stop(
        "--- (!) Only 'ptmph' or 'ptmsites' allowed for argument <ptmType> "
      )
    }
    outlog2fcImputext <-
      gsub(".txt", "-imputedL2fcExtended.txt", output_name)
    write.table(
      imputedDFext,
      outlog2fcImputext,
      quote = FALSE,
      sep = "\t",
      row.names = FALSE,
      col.names = TRUE
    )
    return(imputedDFext)
  }


# ------------------------------------------------------------------------------
# @title Imputing missing values
#
# @description When a value is completely missed in one of the conditions,
# the `log2fc = Inf / -Inf`. This function imputes those values, i.e.,
# will assign 'artificial' values.
# The imputation method works as follow. The assumption is that those
# proteins are likely present as well in those conditions where are found
# missed, but due to the small sampling (usually 2 or 3 biological replicas)
# and other proteomics related issues, those proteins didn't make it through
# the level of detection.
# Therefore, a small intensity (sampled from the bottom 10 intensity values)
# will be assigned to the protein/site in the missing condition,
# and the new log2fc is re-calculated out of the MSstats box.
# Two issues are addressed as follows:
# 1. If a protein has been consistently identified in one of the conditions,
# it will stay
# 2. But if the intensity value in those conditions was too low,
# then the log2fc will be also low
# @param dflog2fcinfinites data.frame of proteins with only infinite
# values from the msstats results file
# @param dfmq Abundance data, which will be used to know the details of
# reproducibility
# @return Imputed missing values
# @keywords internal, imputation, log2fc, quantifications, missing values
.artms_imputeMissingValues <- function(dflog2fcinfinites, 
                                       dfmq) {
  
  # The comparsions
  contrast <- unique(dflog2fcinfinites$Label)
  
  # Select the IDs to impute
  ids2impute <- unique(dflog2fcinfinites$Protein)
  
  # Take the abundance values for all the proteins
  abu2imp <- .artms_loadModelqcBasic(dfmq)
  # Aggregate the technical replica by choosing the maximum value
  abu2imp2 <- aggregate(Abundance ~ Protein + Condition + BioReplicate,
                        data = abu2imp,
                        FUN = mean)
    
  
  # Check things that will be imputed
  # dfdc.ni <- data.table::dcast(data=abu2imp2, 
  # Protein~BioReplicate, value.var = "Abundance")
  
  # Two possible options here.
  # 1. Select based on the bottom x%
  # # Imputing the missing values by selecting randomly from the bottom 5%
  # theMin <- min(dfmq$ABUNDANCE)
  # # Select the 5% quartile as the maximum value to sample from
  # theMax <- quantile(dfmq$ABUNDANCE, probs = .05)
  #
  # 2. Select the bottom 20 intensities
  # Grab the bottom 30 intensities in the dataset
  dfmqOrdered <- dfmq[order(dfmq$ABUNDANCE, decreasing = FALSE), ]
  
  numberFromBottom <- 5
  abuBottom <- head(dfmqOrdered$ABUNDANCE, n = numberFromBottom)
  
  theMin <- abuBottom[1]
  theMax <- abuBottom[numberFromBottom]
  
  # Generating the numbers from which we are going to sample
  numbers2sample <- seq(from = theMin, to = theMax, by = .00001)
  
  # dcast on abundance and fill with random numbers between the minimum and q05
  suppressWarnings(
    dfdc.im <- data.table::dcast(data = abu2imp2,
                                 Protein ~ BioReplicate,
                                 value.var = "Abundance",
                                 fill = sample(numbers2sample, 
                                               replace = FALSE)
    )
  )
  
  # Needs to aggregate on biological replicas
  # 1. Melt on biological replicas
  dfdc.melt <- data.table::melt(dfdc.im,
                                id.vars = c('Protein'),
                                value.name = 'Abundance',
                                variable.name = 'BioReplicate')

  # 2. Get the condition
  dfdc.melt$Condition <- gsub("(.*)(-)(.*)", "\\1", dfdc.melt$BioReplicate)
    
  # 3. Dcast and Aggregate on the condition, taking the mean
  dfdc.final <-
    data.table::dcast(
      data = dfdc.melt,
      Protein ~ Condition,
      value.var = 'Abundance',
      fun.aggregate = mean
    )
  # 4. Filter by proteins to impute
  dfdc.final <- dfdc.final[which(dfdc.final$Protein %in% ids2impute), ]
    
  
  for (c in contrast) {
    # message("\t",c," --> ")
    x <- gsub("(.*)(-)(.*)", "\\1", c)
    y <- gsub("(.*)(-)(.*)", "\\3", c)
    # message("log2fc(",x, " - ", y,") ")
    
    # Renaming the comparision name just for illustration purposes
    rnc <- paste0("l2fc_", c)
    
    dfdc.final[[rnc]] <- dfdc.final[[x]] - dfdc.final[[y]]
  }
  
  # Select only log2fc columns
  imputedL2FCValues <-
    dfdc.final[grepl("Protein|l2fc_", colnames(dfdc.final))]
  
  # Melt again
  imputedL2FCmelted <- data.table::melt(imputedL2FCValues,
                                        id.vars = c('Protein'),
                                        variable.name = 'Label',
                                        value.name = 'iLog2FC')
    
    
  # Now let's get it ready for merging with the values to be 
  # imputed at dflog2fcinfinites
  imputedL2FCmelted$Label <- gsub("l2fc_", "", imputedL2FCmelted$Label)
    
  
  # And let's add p-values
  samplingPvalue <- seq(from = 0.01, to = 0.05, by = .0000001)
  # And add imputed pvalues
  imputedL2FCmelted$iPvalue <-
    sample(samplingPvalue,
           size = nrow(imputedL2FCmelted),
           replace = FALSE)
  
  return (imputedL2FCmelted)
}

# ------------------------------------------------------------------------------
# @title Load limited columns from abundance (modelqc) annotated
#
# @description Load limited columns from abundance (modelqc) annotated
# @param df_input (data.frame) with the raw abundance data (modelqc)
# @param species (char) Species name for annotation purposes
# @param ptmis (char) Specify whether is a PTM dataset: `global`, `ptmsites`,
# `ptmph`
# @param verbose (logical) `TRUE` (default) shows function messages
# @return annotated data.frame of abundance data
# @keywords abundance, annotated
.artms_loadModelQCstrict <- function (df_input, 
                                      species, 
                                      ptmis,
                                      verbose = TRUE) {
  # Remove empty entries
  if (any(df_input$PROTEIN == "")) {
    df_input <- df_input[-which(df_input$PROTEIN == ""), ]
  }
  df_input$PROTEIN <- gsub("(^sp\\|)(.*)(\\|.*)", "\\2", df_input$PROTEIN)
  df_input$PROTEIN <- gsub("(.*)(\\|.*)", "\\1", df_input$PROTEIN)
  
  # Technical replicas: aggregate on the mean the technical replicas
  b <- aggregate(
    ABUNDANCE ~ PROTEIN + GROUP_ORIGINAL + SUBJECT_ORIGINAL,
    data = df_input,
    FUN = mean
  )
  
  datadc <- data.table::dcast(
    data = b,
    PROTEIN ~ GROUP_ORIGINAL,
    value.var = 'ABUNDANCE',
    fun.aggregate = mean
  )
  
  names(datadc)[grep('PROTEIN', names(datadc))] <- 'Protein'
  if (grepl("ptm", ptmis)) {
    # if is a PTM dataset we don't need the real gene names for now,
    # we need to use the Uniprot_ptm notation
    datadc$Gene <- datadc$Protein
    send_back <- datadc
  } else{
    suppressMessages(send_back <- artmsAnnotationUniprot(datadc, 'Protein', species))
  }
  return(send_back)
}


#------------------------------------------------------------------------------
# @title Load the basic ModelQC file
#
# @param x (data.frame) of the ModelQC file
# @return (data.frame) of the modelqc file with the columns Protein, Abundance,
# Condition, BioReplicate
# @keywords internal, loading
.artms_loadModelqcBasic <- function(x) {
  ## Not removing protein groups for now
  # if (length(grep(";", x$PROTEIN)) > 0)
  #   x <- x[-grep(";", x$PROTEIN), ]
  
  if ("PROTEIN" %in% colnames(x)) {
    names(x)[grep("PROTEIN", names(x))] <- 'Protein'
  } else{
    stop("<PROTEIN> column not found")
  }
  if ("ABUNDANCE" %in% colnames(x)) {
    names(x)[grep("ABUNDANCE", names(x))] <- 'Abundance'
  } else{
    stop("<ABUNDANCE> protein not found!")
  }
  if ("GROUP_ORIGINAL" %in% colnames(x)) {
    names(x)[grep("GROUP_ORIGINAL", names(x))] <- 'Condition'
  } else{
    stop("<GROUP_ORIGINAL> not found")
  }
  if ("SUBJECT_ORIGINAL" %in% colnames(x)) {
    names(x)[grep("SUBJECT_ORIGINAL", names(x))] <- 'BioReplicate'
  } else{
    stop("<SUBJECT_ORIGINAL> not found")
  }
  x <- subset(x, 
                 select = c(Protein, Abundance, Condition, BioReplicate))
  return(x)
}

# ------------------------------------------------------------------------------
# @title Merge abundance and number of biological replicates per condition
#
# @description Merge abundance and number of biological replicates
# per condition
# @param df_input (data.frame) Abundance input file
# @param repro (data.frame) Reproducibility data.frame
# @param species (char) Species for annotation purposes
# @return (data.frame) of abundance merged with reproducibility info
# @keywords abundance, reproducibility, merging
.artms_mergeAbNbr <- function (df_input, repro, species) {
  # Remove empty entries
  if (any(df_input$PROTEIN == "")) {
    df_input <- df_input[-which(df_input$PROTEIN == ""), ]
  }
  df_input$PROTEIN <-
    gsub("(^sp\\|)(.*)(\\|.*)", "\\2", df_input$PROTEIN)
  df_input$PROTEIN <- gsub("(.*)(\\|.*)", "\\1", df_input$PROTEIN)
  
  # TECHNICAL REPLICAS: if there are technical replicas, 
  # this means that we will find
  # two values for the same protein in the same bioreplica, 
  # therefore we need to aggregate first just in case:
  df_input <-
    aggregate(
      ABUNDANCE ~ PROTEIN + GROUP_ORIGINAL + SUBJECT_ORIGINAL,
      data = df_input,
      FUN = mean
    )
  
  dc_input <-
    data.table::dcast(
      data = df_input[, c('PROTEIN', 'ABUNDANCE', 'GROUP_ORIGINAL')],
      PROTEIN ~ GROUP_ORIGINAL,
      value.var = 'ABUNDANCE',
      fun.aggregate = mean,
      fill = 0
    )
  names(dc_input)[grep('PROTEIN', names(dc_input))] <- 'Protein'
  
  colnames(repro) <- paste("NumBR", colnames(repro), sep = "_")
  colnames(repro)[1] <- 'Protein'
  dc_input <- merge(dc_input, repro, by = c('Protein'))
  
  return(dc_input)
}

# ------------------------------------------------------------------------------
# @title Merge changes (log2fc) and number of biological replicates per
# condition
#
# @description Merge changes, i.e., MSstats results file of quantified changes,
# with the number of biological replicates per condition
# @param df_input Changes data.frame
# @param repro Reproducibility data.frame
# @param species Species for annotation purposes
# @return Merged data.frame of changes and reproducibility information
# @keywords changes, log2fc, reproducibility, merging
.artms_mergeChangesNbr <- function (df_input, repro, species) {
  # # Remove the weird empty proteins
  # if(any(df_input$Protein == "")){ df_input <- 
  # df_input[-which(df_input$Protein == ""),]}
  # df_input$Protein <- gsub("(^sp\\|)(.*)(\\|.*)", "\\2", df_input$Protein )
  # df_input$Protein <- gsub("(.*)(\\|.*)", "\\1", df_input$Protein )
  
  input_melt = data.table::melt(data = df_input[, c('Protein', 
                                                  'Label', 
                                                  'log2FC', 
                                                  'adj.pvalue'), ], 
                                id.vars = c('Protein', 'Label'))
  input_dcast = data.table::dcast(Protein ~ Label + variable,
                                  data = input_melt,
                                  value.var = c('value'))
  
  colnames(repro) <- paste("NumBR", colnames(repro), sep = "_")
  colnames(repro)[1] <- 'Protein'
  input_dcast <- merge(input_dcast, repro, by = c('Protein'))
  
  # Move Gene name to the left:
  return(input_dcast)
}

# ------------------------------------------------------------------------------
# @title Plot the total number of quantified proteins in each condition
#
# @description
# @keys internal, plot, counts
# @param x (data.frame) Data frame of imputed log2fc
.artms_plotNumberProteinsImputedLog2fc <- function(x) {
  x <- x[c('Protein', 'Comparison')]
  y <- unique(x)
  z <- ggplot(y, aes(x = Comparison, fill = Comparison))
  z <- z + geom_bar(stat = "count",
                    na.rm = TRUE)
  z <-
    z + theme(axis.text.x = element_text(
      angle = 90,
      hjust = 1,
      vjust = 0.5
    ))
  z <-
    z + geom_text(
      stat = 'count',
      aes(label = ..count..),
      vjust = -0.5,
      size = 2.7
    )
  z <- z + ggtitle("Unique Proteins in Comparisons")
  print(z)
}

# ------------------------------------------------------------------------------
# @title Filter: Remove proteins below some threshold of minimal reproducibility
#
# @description If a protein is not found in a minimal number of
# biological replicates in at least one of the conditions, it is removed
# @param dfi (data.frame) Data.frame with biological replicates information
# @param mnbr (int) minimal number of biological replicates
# @return (data.frame) a filtered `dfi`
# @keywords internal, filter, bioreplicates, reproducibility
.artms_RemoveProtBelowThres <- function(dfi, mnbr) {
  theComparisons2check <- unique(dfi$Label)
  for (onlyonecomp in (theComparisons2check)) {
    ax <- gsub("(.*)(-)(.*)", "\\1", onlyonecomp)
    ay <- gsub("(.*)(-)(.*)", "\\3", onlyonecomp)
    
    # If the condition is not met, i.e., if all the proteins are
    # found in at least X biological replicas, then
    # it would remove the whole thing.
    if (dim(dfi[which((dfi[[ax]] < mnbr) &
                      (dfi[[ay]] < mnbr)), ])[1] > 0) {
      dfi <-
        dfi[-which(((dfi[[ax]] < mnbr) &
                      (dfi[[ay]] < mnbr)) & (dfi$Label == onlyonecomp)), ]
    }
  }
  return(dfi)
}

# ------------------------------------------------------------------------------
# @title Select and label the condition more abundant in a quantification
#
# @description Select and label the condition more abundant in a quantification
# - If log2fc > 0 the condition on the left ('numerator') is the most abundant
# - If log2fc < 0 the condition on the right ('denominator') 
# is the most abundant
# @param a (char) log2fc column
# @param b (char) comparison column
# @return (char) One of the conditions from the comparison
# @keywords internal, selection, labeling
.artms_selectTheOneLog2fc <- function(a, b) {
  thrs <- 0
  # a should be the log2fc column
  if (a > thrs) {
    sb <- gsub("(.*)(-)(.*)", "\\1", b)
  } else if (a < -thrs) {
    sb <- gsub("(.*)(-)(.*)", "\\3", b)
  } else {
    sb <- 'NA'
  }
  return(sb)
}



# ------------------------------------------------------------------------------
# @title Extract Uniprot ID from a UNIPROT_PTM  identifier
#
# @param x The data.frame with the uniprot_ptm column
# @param uniprotPtmColumn (char) Column in the data.frame with the Uniprot_PTM
# IDs
# @param newColumnName (char) Name of the new column that will contain the
# Uniprot ids
# @return (char) One of the conditions from the comparison
# @keywords internal, selection, labeling
.artmsExtractUniprotId <- function(x, uniprotPtmColumn, newColumnName){
  if(any(missing(x) | missing(newColumnName) | missing(uniprotPtmColumn)))
    stop("Missed (one or many) required argument(s)
         Please, check the help of this function to find out more")
  
  if(!is.character(newColumnName)) 
    stop("Argument 'newColumnName' must be a character")
  if(!is.character(uniprotPtmColumn)) 
    stop("Argument 'uniprotPtmColumn' must be a character")
  
  x[[newColumnName]] <- ifelse(
    grepl("_H1N1|_H3N2|_H5N1", 
          x[[uniprotPtmColumn]]),
    gsub("^(\\S+?_H[1,3,5]N[1,2])_.*",
         "\\1",
         x[[uniprotPtmColumn]],
         perl = TRUE) ,
    gsub("^(\\S+?)_.*", 
         "\\1", 
         x[[uniprotPtmColumn]], 
         perl = TRUE) 
  )
  return(x)
}

